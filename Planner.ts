///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                result.plan.push("new interpretation");
                result.plan.push(toString(result.interpretation));
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions

    /**
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d".
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        var timeout : number = 1000;

        var objects = state.objects;

        var plan : string[] = [];

        // heuristics
        // getHeuristics();

        // define a goal state
        // var goal = ;

        // create graph
        //  - neighbour function
        //  - compare function

        // A* planner (graph, start, goal, heuristics, timeout)
        // var path = aStarSearch(null, null, null, null, timeout);

        return plan;
    }

    function isGoal(state : WorldState, interpretation : Interpreter.DNFFormula) : boolean {
        var res = interpretation.some(function (interp) {
            return interp.every(function (literal) {
                if(literal.relation == "holding"){
                    return (literal.args[0] == state.holding);
                }else{
                    //TODO probably call relationcheck 
                    return true;
                }
            });
        });
        return res;
    }

    class StateGraph implements Graph<WorldState> {

        /** Computes the edges that leave from a node. */
        outgoingEdges(state : WorldState) : Edge<WorldState>[] {
            return null;
        }
        /** A function that compares nodes. */
        //collections.ICompareFunction<WorldState>
        compareNodes (state : WorldState) : number {
            return 0;
        }

    }


    function toString(interpretation : Interpreter.DNFFormula) : string{
        var result : string = "";

        for(var i = 0; i < interpretation.length; i++){
            for(var j = 0; j < interpretation[i].length; j++){
                result = result.concat(interpretation[i][j].relation + "(");
                for(var k = 0; k < interpretation[i][j].args.length; k++){
                    result = result.concat(interpretation[i][j].args[k]);
                    if(k + 1  < interpretation[i][j].args.length)
                        result = result.concat(", ");
                }
                result = result.concat(")    ")
            }
        }
        return result;
    }

}
